#!/bin/bash
set -euo pipefail

echo "üöÄ Stage 2: Post-reboot setup starting..."

# Source environment variables if available
if [[ -f /opt/stage2-env.sh ]]; then
  echo "üîß Loading environment variables from stage2-env.sh# Wait a bit more for Docker to fully initialize its iptables rules
echo "‚è≥ Waiting for Docker iptables initialization..."
sleep 10

# Test Docker network creation to ensure iptables fix worked
echo "üß™ Testing Docker network creation capability..."
TEST_NETWORK="test-docker-fix-$(date +%s)"
if docker network create "$TEST_NETWORK" >/dev/null 2>&1; then
    echo "‚úÖ Docker network creation test successful"
    docker network rm "$TEST_NETWORK" >/dev/null 2>&1
    echo "‚úÖ Docker iptables fix confirmed working"
else
    echo "‚ùå Docker network creation test failed"
    echo "üîç Checking Docker daemon logs..."
    journalctl -u docker --no-pager -l --since="5 minutes ago" | tail -20 || true
    echo "‚ö†Ô∏è Docker networking may still have issues - check deployment logs"
fi
  echo "‚úÖ Environment variables loaded"
  # Check if environment variables are available (safe syntax)
  if [[ -n "${TS_OAUTH_CLIENT_ID_ENV:-}" ]]; then
    echo "üîç Debug: TS_OAUTH_CLIENT_ID_ENV length: ${#TS_OAUTH_CLIENT_ID_ENV}"
  else
    echo "üîç Debug: TS_OAUTH_CLIENT_ID_ENV not set"
  fi
  if [[ -n "${TS_OAUTH_SECRET_ENV:-}" ]]; then
    echo "üîç Debug: TS_OAUTH_SECRET_ENV length: ${#TS_OAUTH_SECRET_ENV}"
  else
    echo "üîç Debug: TS_OAUTH_SECRET_ENV not set"
  fi
else
  echo "‚ö†Ô∏è No environment file found at /opt/stage2-env.sh"
fi

# Get configuration variables (should be replaced by the workflow)
TS_OAUTH_CLIENT_ID="TS_OAUTH_CLIENT_ID_PLACEHOLDER"
TS_OAUTH_SECRET="TS_OAUTH_SECRET_PLACEHOLDER"
TAILSCALE_TAILNET="TAILSCALE_TAILNET_PLACEHOLDER"
SERVICE_NAME="SERVICE_NAME_PLACEHOLDER"
DOMAIN_NAME="DOMAIN_NAME_PLACEHOLDER"
CLOUDFLARE_EMAIL="CLOUDFLARE_EMAIL_PLACEHOLDER"
CLOUDFLARE_API_TOKEN="CLOUDFLARE_API_TOKEN_PLACEHOLDER"
ADMIN_EMAIL="ADMIN_EMAIL_PLACEHOLDER"

# Fallback: Check for direct GitHub Actions environment variables first
echo "üîç Checking for GitHub Actions environment variables..."
if [[ -n "${GITHUB_ACTIONS_TS_OAUTH_CLIENT_ID:-}" ]]; then
  echo "‚úÖ Found TS_OAUTH_CLIENT_ID in GitHub Actions environment"
  TS_OAUTH_CLIENT_ID="$GITHUB_ACTIONS_TS_OAUTH_CLIENT_ID"
fi

if [[ -n "${GITHUB_ACTIONS_TS_OAUTH_SECRET:-}" ]]; then
  echo "‚úÖ Found TS_OAUTH_SECRET in GitHub Actions environment"
  TS_OAUTH_SECRET="$GITHUB_ACTIONS_TS_OAUTH_SECRET"
fi

if [[ -n "${GITHUB_ACTIONS_SERVICE_NAME:-}" ]]; then
  echo "‚úÖ Found SERVICE_NAME in GitHub Actions environment"
  SERVICE_NAME="$GITHUB_ACTIONS_SERVICE_NAME"
fi

if [[ -n "${GITHUB_ACTIONS_DOMAIN_NAME:-}" ]]; then
  echo "‚úÖ Found DOMAIN_NAME in GitHub Actions environment"
  DOMAIN_NAME="$GITHUB_ACTIONS_DOMAIN_NAME"
fi

if [[ -n "${GITHUB_ACTIONS_CLOUDFLARE_EMAIL:-}" ]]; then
  echo "‚úÖ Found CLOUDFLARE_EMAIL in GitHub Actions environment"
  CLOUDFLARE_EMAIL="$GITHUB_ACTIONS_CLOUDFLARE_EMAIL"
fi

if [[ -n "${GITHUB_ACTIONS_CLOUDFLARE_API_TOKEN:-}" ]]; then
  echo "‚úÖ Found CLOUDFLARE_API_TOKEN in GitHub Actions environment"
  CLOUDFLARE_API_TOKEN="$GITHUB_ACTIONS_CLOUDFLARE_API_TOKEN"
fi

if [[ -n "${GITHUB_ACTIONS_ADMIN_EMAIL:-}" ]]; then
  echo "‚úÖ Found ADMIN_EMAIL in GitHub Actions environment"
  ADMIN_EMAIL="$GITHUB_ACTIONS_ADMIN_EMAIL"
fi

# Validate that placeholders were replaced, or try environment variables as fallback
if [[ "$TS_OAUTH_CLIENT_ID" == "TS_OAUTH_CLIENT_ID_PLACEHOLDER" || "$TS_OAUTH_CLIENT_ID" == "***" ]]; then
  echo "‚ö†Ô∏è TS_OAUTH_CLIENT_ID placeholder was not replaced by workflow or is masked"
  if [[ -n "${TS_OAUTH_CLIENT_ID_ENV:-}" ]]; then
    echo "üîÑ Using TS_OAUTH_CLIENT_ID from environment variable"
    TS_OAUTH_CLIENT_ID="$TS_OAUTH_CLIENT_ID_ENV"
  else
    echo "‚ùå No TS_OAUTH_CLIENT_ID found in environment either!"
    echo "üîç Available environment variables:"
    env | grep -E "(TS_|OAUTH|CLIENT)" || echo "No OAuth-related variables found"
    exit 1
  fi
fi

if [[ "$TS_OAUTH_SECRET" == "TS_OAUTH_SECRET_PLACEHOLDER" || "$TS_OAUTH_SECRET" == "***" ]]; then
  echo "‚ö†Ô∏è TS_OAUTH_SECRET placeholder was not replaced by workflow or is masked"
  if [[ -n "${TS_OAUTH_SECRET_ENV:-}" ]]; then
    echo "üîÑ Using TS_OAUTH_SECRET from environment variable"
    TS_OAUTH_SECRET="$TS_OAUTH_SECRET_ENV"
  else
    echo "‚ùå No TS_OAUTH_SECRET found in environment either!"
    exit 1
  fi
fi

if [[ "$SERVICE_NAME" == "SERVICE_NAME_PLACEHOLDER" || "$SERVICE_NAME" == "***" ]]; then
  echo "‚ö†Ô∏è SERVICE_NAME placeholder was not replaced by workflow or is masked"
  if [[ -n "${SERVICE_NAME_ENV:-}" ]]; then
    echo "üîÑ Using SERVICE_NAME from environment variable"
    SERVICE_NAME="$SERVICE_NAME_ENV"
  else
    echo "‚ùå No SERVICE_NAME found in environment either!"
    exit 1
  fi
fi

# Handle optional Cloudflare credentials (don't exit on failure, just warn)
if [[ "$CLOUDFLARE_EMAIL" == "CLOUDFLARE_EMAIL_PLACEHOLDER" || "$CLOUDFLARE_EMAIL" == "***" ]]; then
  echo "‚ö†Ô∏è CLOUDFLARE_EMAIL placeholder was not replaced by workflow or is masked"
  if [[ -n "${CLOUDFLARE_EMAIL_ENV:-}" ]]; then
    echo "üîÑ Using CLOUDFLARE_EMAIL from environment variable"
    CLOUDFLARE_EMAIL="$CLOUDFLARE_EMAIL_ENV"
  else
    echo "‚ÑπÔ∏è No CLOUDFLARE_EMAIL found in environment - DNS updates will be skipped"
    CLOUDFLARE_EMAIL=""
  fi
fi

if [[ "$CLOUDFLARE_API_TOKEN" == "CLOUDFLARE_API_TOKEN_PLACEHOLDER" || "$CLOUDFLARE_API_TOKEN" == "***" ]]; then
  echo "‚ö†Ô∏è CLOUDFLARE_API_TOKEN placeholder was not replaced by workflow or is masked"
  if [[ -n "${CLOUDFLARE_API_TOKEN_ENV:-}" ]]; then
    echo "üîÑ Using CLOUDFLARE_API_TOKEN from environment variable"
    CLOUDFLARE_API_TOKEN="$CLOUDFLARE_API_TOKEN_ENV"
  else
    echo "‚ÑπÔ∏è No CLOUDFLARE_API_TOKEN found in environment - DNS updates will be skipped"
    CLOUDFLARE_API_TOKEN=""
  fi
fi

if [[ "$ADMIN_EMAIL" == "ADMIN_EMAIL_PLACEHOLDER" || "$ADMIN_EMAIL" == "***" ]]; then
  echo "‚ö†Ô∏è ADMIN_EMAIL placeholder was not replaced by workflow or is masked"
  if [[ -n "${ADMIN_EMAIL_ENV:-}" ]]; then
    echo "üîÑ Using ADMIN_EMAIL from environment variable"
    ADMIN_EMAIL="$ADMIN_EMAIL_ENV"
  else
    echo "‚ÑπÔ∏è No ADMIN_EMAIL found in environment - using default"
    ADMIN_EMAIL="admin@example.com"
  fi
fi

echo "‚úÖ Configuration loaded: SERVICE_NAME=$SERVICE_NAME"
echo "üîç Cloudflare configuration status:"
echo "  ‚Ä¢ CLOUDFLARE_EMAIL: $(if [[ -n "$CLOUDFLARE_EMAIL" ]]; then echo "configured (${#CLOUDFLARE_EMAIL} chars)"; else echo "not configured"; fi)"
echo "  ‚Ä¢ CLOUDFLARE_API_TOKEN: $(if [[ -n "$CLOUDFLARE_API_TOKEN" ]]; then echo "configured (${#CLOUDFLARE_API_TOKEN} chars)"; else echo "not configured"; fi)"

echo "üì¶ Installing firewall packages after reboot..."
# First, remove old iptables if it exists to avoid conflicts
echo "üîß Resolving iptables conflicts..."
pacman -Rdd --noconfirm iptables 2>/dev/null || true

# Now install iptables-nft, ufw, jq, and curl (for API calls and DNS updates)
if ! pacman -S --noconfirm iptables-nft ufw jq curl; then
  echo "‚ö†Ô∏è First attempt failed, trying individually..."
  pacman -S --noconfirm iptables-nft || echo "Failed to install iptables-nft"
  pacman -S --noconfirm ufw || echo "Failed to install ufw"
  pacman -S --noconfirm jq || echo "Failed to install jq"
  pacman -S --noconfirm curl || echo "Failed to install curl"
fi

echo "‚úÖ Firewall packages installed successfully"

echo "üî• Configuring firewall before starting services..."
ufw --force reset
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh

echo "üîß Initializing iptables chains for Docker..."
# Create all necessary Docker chains with improved error handling
create_docker_chain() {
    local table="$1"
    local chain="$2"
    
    if ! iptables -t "$table" -L "$chain" >/dev/null 2>&1; then
        echo "  Creating $table/$chain chain..."
        iptables -t "$table" -N "$chain" 2>/dev/null || true
    else
        echo "  Chain $table/$chain already exists"
    fi
}

# Create NAT chains
create_docker_chain "nat" "DOCKER"

# Create FILTER chains (including the missing DOCKER-CT chain)
create_docker_chain "filter" "DOCKER"
create_docker_chain "filter" "DOCKER-ISOLATION-STAGE-1"
create_docker_chain "filter" "DOCKER-ISOLATION-STAGE-2"
create_docker_chain "filter" "DOCKER-USER"
create_docker_chain "filter" "DOCKER-CT"

# Set up the chain rules that Docker expects
echo "  Setting up Docker chain rules..."
iptables -t nat -C PREROUTING -m addrtype --dst-type LOCAL -j DOCKER 2>/dev/null || \
  iptables -t nat -I PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
iptables -t nat -C OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER 2>/dev/null || \
  iptables -t nat -I OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
iptables -t filter -C FORWARD -j DOCKER-USER 2>/dev/null || \
  iptables -t filter -I FORWARD -j DOCKER-USER
iptables -t filter -C FORWARD -j DOCKER-ISOLATION-STAGE-1 2>/dev/null || \
  iptables -t filter -I FORWARD -j DOCKER-ISOLATION-STAGE-1
iptables -t filter -C DOCKER-USER -j RETURN 2>/dev/null || \
  iptables -t filter -A DOCKER-USER -j RETURN

echo "‚úÖ Docker iptables chains initialized"

echo "üê≥ Starting Docker service..."
systemctl start docker

echo "‚è≥ Waiting for Docker to be ready..."
for i in {1..10}; do
  if docker info >/dev/null 2>&1; then
    echo "‚úÖ Docker is ready"
    break
  fi
  echo "Attempt $i/10: Waiting for Docker..."
  sleep 5
done

# Wait a bit more for Docker to fully initialize its iptables rules
echo "‚è≥ Waiting for Docker iptables initialization..."
sleep 10

# Skip Docker network creation in stage2 - let the application deployment handle it
echo "‚ÑπÔ∏è Docker network creation will be handled during application deployment"
echo "ÔøΩ Verifying Docker basic functionality..."
docker network ls

echo "‚è≥ Waiting for Docker networking to stabilize..."
sleep 10

# Verify Docker is working properly before proceeding
echo "üîç Verifying Docker network status..."
docker network ls
docker info | grep -A 5 "Network:" || echo "‚ö†Ô∏è Network section not found in docker info (this is normal on some systems)"

echo "üîó Starting and authenticating Tailscale..."
systemctl start tailscaled

echo "‚è≥ Waiting for tailscaled daemon to start..."
for i in {1..15}; do
  if systemctl is-active tailscaled >/dev/null 2>&1; then
    echo "‚úÖ Tailscaled daemon is active"
    break
  fi
  echo "Attempt $i/15: Waiting for tailscaled..."
  sleep 3
done

# Validate OAuth credentials were set properly
if [[ "$TS_OAUTH_CLIENT_ID" == "TS_OAUTH_CLIENT_ID_PLACEHOLDER" ]]; then
  echo "‚ö†Ô∏è TS_OAUTH_CLIENT_ID placeholder was not replaced by workflow"
  if [[ -n "${TS_OAUTH_CLIENT_ID:-}" ]]; then
    echo "üîÑ Using TS_OAUTH_CLIENT_ID from environment variable"
    TS_OAUTH_CLIENT_ID="$TS_OAUTH_CLIENT_ID"
  else
    echo "‚ùå TS_OAUTH_CLIENT_ID not available in environment either!"
    echo "üîç Available environment variables starting with TS:"
    env | grep -i "^TS" || echo "None found"
    exit 1
  fi
fi

if [[ "$TS_OAUTH_SECRET" == "TS_OAUTH_SECRET_PLACEHOLDER" ]]; then
  echo "‚ö†Ô∏è TS_OAUTH_SECRET placeholder was not replaced by workflow"
  if [[ -n "${TS_OAUTH_SECRET:-}" ]]; then
    echo "üîÑ Using TS_OAUTH_SECRET from environment variable"
    TS_OAUTH_SECRET="$TS_OAUTH_SECRET"
  else
    echo "‚ùå TS_OAUTH_SECRET not available in environment either!"
    exit 1
  fi
fi

if [[ "$SERVICE_NAME" == "SERVICE_NAME_PLACEHOLDER" ]]; then
  echo "‚ö†Ô∏è SERVICE_NAME placeholder was not replaced by workflow"
  if [[ -n "${SERVICE_NAME_ENV:-}" ]]; then
    echo "üîÑ Using SERVICE_NAME_ENV from environment variable"
    SERVICE_NAME="$SERVICE_NAME_ENV"
  else
    # Try to get from hostname as fallback
    SERVICE_NAME=$(hostname)
    echo "üîÑ Using hostname as service name: $SERVICE_NAME"
  fi
fi

if [[ -z "$TS_OAUTH_CLIENT_ID" || -z "$TS_OAUTH_SECRET" ]]; then
  echo "‚ùå Tailscale OAuth credentials are empty"
  exit 1
fi

echo "üîó Authenticating with Tailscale using OAuth..."
echo "Using hostname: $SERVICE_NAME"

# Get OAuth access token for Tailscale API
echo "üîë Getting Tailscale OAuth access token..."
OAUTH_RESPONSE=$(curl -s -X POST https://api.tailscale.com/api/v2/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=${TS_OAUTH_CLIENT_ID}" \
  -d "client_secret=${TS_OAUTH_SECRET}" 2>/dev/null || echo "CURL_FAILED")

if [[ "$OAUTH_RESPONSE" == "CURL_FAILED" ]]; then
  echo "‚ùå OAuth request failed"
  exit 1
fi

# Extract access token
ACCESS_TOKEN=$(echo "$OAUTH_RESPONSE" | jq -r '.access_token // empty' 2>/dev/null || echo "")

if [[ -z "$ACCESS_TOKEN" || "$ACCESS_TOKEN" == "null" || "$ACCESS_TOKEN" == "empty" ]]; then
  echo "‚ùå Failed to get OAuth access token"
  echo "OAuth response: $OAUTH_RESPONSE"
  exit 1
fi

echo "‚úÖ OAuth access token obtained"

# Get tailnet information
if [[ "$TAILSCALE_TAILNET" == "TAILSCALE_TAILNET_PLACEHOLDER" || -z "$TAILSCALE_TAILNET" ]]; then
  echo "üîç Getting tailnet information..."
  TAILNET_RESPONSE=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" \
    "https://api.tailscale.com/api/v2/tailnet" 2>/dev/null || echo "CURL_FAILED")
  
  if [[ "$TAILNET_RESPONSE" != "CURL_FAILED" ]]; then
    TAILNET=$(echo "$TAILNET_RESPONSE" | jq -r '.tailnets[0] // empty' 2>/dev/null || echo "")
    if [[ -n "$TAILNET" && "$TAILNET" != "null" && "$TAILNET" != "empty" ]]; then
      TAILSCALE_TAILNET="$TAILNET"
      echo "‚úÖ Auto-detected tailnet: $TAILSCALE_TAILNET"
    fi
  fi
fi

# Create ephemeral auth key using OAuth API
echo "üîë Creating ephemeral Tailscale auth key..."
AUTH_KEY_RESPONSE=$(curl -s -X POST \
  "https://api.tailscale.com/api/v2/tailnet/${TAILSCALE_TAILNET}/keys" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "capabilities": {
      "devices": {
        "create": {
          "reusable": false,
          "ephemeral": true,
          "preauthorized": true,
          "tags": ["tag:ci"]
        }
      }
    },
    "expirySeconds": 3600
  }' 2>/dev/null || echo "CURL_FAILED")

if [[ "$AUTH_KEY_RESPONSE" == "CURL_FAILED" ]]; then
  echo "‚ùå Failed to create auth key"
  exit 1
fi

# Extract the auth key
AUTH_KEY=$(echo "$AUTH_KEY_RESPONSE" | jq -r '.key // empty' 2>/dev/null || echo "")

if [[ -z "$AUTH_KEY" || "$AUTH_KEY" == "null" || "$AUTH_KEY" == "empty" ]]; then
  echo "‚ùå Failed to extract auth key"
  echo "Auth key response: $AUTH_KEY_RESPONSE"
  exit 1
fi

echo "‚úÖ Auth key created successfully"

TAILSCALE_CONNECTED=false
DOCKER_SUBNETS="172.17.0.0/16,172.20.0.0/16,172.21.0.0/16,172.22.0.0/16"

# Enhanced connection attempts with better error handling
CONNECTION_METHODS=(
  "full-with-reset"
  "full-no-reset" 
  "basic-with-reset"
  "basic-no-reset"
  "minimal"
)

for method in "${CONNECTION_METHODS[@]}"; do
  echo "üåê Attempting Tailscale connection method: $method"
  
  case "$method" in
    "full-with-reset")
      if timeout 300 tailscale up --authkey="$AUTH_KEY" --hostname="$SERVICE_NAME" --accept-routes --advertise-routes="$DOCKER_SUBNETS" --reset; then
        TAILSCALE_CONNECTED=true
        echo "‚úÖ Tailscale connected with full configuration and reset"
        break
      fi
      ;;
    "full-no-reset")
      if timeout 300 tailscale up --authkey="$AUTH_KEY" --hostname="$SERVICE_NAME" --accept-routes --advertise-routes="$DOCKER_SUBNETS"; then
        TAILSCALE_CONNECTED=true
        echo "‚úÖ Tailscale connected with full configuration"
        break
      fi
      ;;
    "basic-with-reset")
      if timeout 300 tailscale up --authkey="$AUTH_KEY" --hostname="$SERVICE_NAME" --accept-routes --reset; then
        TAILSCALE_CONNECTED=true
        echo "‚úÖ Tailscale connected with basic configuration and reset"
        
        # Try to add subnet advertisement after connection
        echo "üîÑ Attempting to add Docker subnet advertisement..."
        sleep 10
        timeout 60 tailscale up --advertise-routes="$DOCKER_SUBNETS" || echo "‚ö†Ô∏è Failed to advertise subnets, but connection established"
        break
      fi
      ;;
    "basic-no-reset")
      if timeout 300 tailscale up --authkey="$AUTH_KEY" --hostname="$SERVICE_NAME" --accept-routes; then
        TAILSCALE_CONNECTED=true
        echo "‚úÖ Tailscale connected with basic configuration"
        
        # Try to add subnet advertisement after connection
        echo "üîÑ Attempting to add Docker subnet advertisement..."
        sleep 10
        timeout 60 tailscale up --advertise-routes="$DOCKER_SUBNETS" || echo "‚ö†Ô∏è Failed to advertise subnets, but connection established"
        break
      fi
      ;;
    "minimal")
      if timeout 300 tailscale up --authkey="$AUTH_KEY"; then
        TAILSCALE_CONNECTED=true
        echo "‚úÖ Tailscale connected with minimal configuration"
        echo "‚ö†Ô∏è No route acceptance or subnet advertisement - manual configuration may be needed"
        break
      fi
      ;;
  esac
  
  echo "‚ö†Ô∏è Method $method failed, trying next approach..."
  sleep 10
done

if [[ "$TAILSCALE_CONNECTED" != "true" ]]; then
  echo "‚ùå All Tailscale connection methods failed"
  echo "üîç Checking tailscale logs..."
  journalctl -u tailscaled --no-pager -l --since="10 minutes ago" || true
  echo "üîç Tailscale status output:"
  tailscale status || true
fi

if [[ "$TAILSCALE_CONNECTED" == "true" ]]; then
  echo "üîç Quick Tailscale IP assignment check..."
  TAILSCALE_IP="pending"
  
  # Quick check - if we're logged in, get the IP immediately
  if tailscale status | grep -q "Logged in"; then
    CURRENT_IP=$(tailscale ip -4 2>/dev/null || echo "")
    if [[ -n "$CURRENT_IP" && "$CURRENT_IP" != "" ]]; then
      TAILSCALE_IP="$CURRENT_IP"
      echo "‚úÖ Tailscale IP available immediately: $TAILSCALE_IP"
    else
      # Brief wait for IP assignment - but only 3 attempts max
      echo "‚è≥ Brief wait for IP assignment..."
      for i in {1..3}; do
        CURRENT_IP=$(tailscale ip -4 2>/dev/null || echo "")
        if [[ -n "$CURRENT_IP" && "$CURRENT_IP" != "" ]]; then
          TAILSCALE_IP="$CURRENT_IP"
          echo "‚úÖ Tailscale IP assigned: $TAILSCALE_IP"
          break
        fi
        echo "Attempt $i/3: Waiting for IP..."
        sleep 5
      done
      
      # If still no IP, proceed anyway - we can get it later
      if [[ "$TAILSCALE_IP" == "pending" ]]; then
        echo "‚ö†Ô∏è IP not immediately available, but Tailscale is connected - proceeding"
        # Try one more time with a different method
        TAILSCALE_IP=$(tailscale status --self --peers=false 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1 || echo "pending")
        if [[ "$TAILSCALE_IP" != "pending" ]]; then
          echo "‚úÖ Got IP via status command: $TAILSCALE_IP"
        fi
      fi
    fi
  fi
  
  echo "$TAILSCALE_IP" > /tmp/tailscale_ip
  
  # Update Cloudflare DNS records with Tailscale IP
  if [[ "$TAILSCALE_IP" != "pending" && -n "$TAILSCALE_IP" ]]; then
    echo "üåê Updating Cloudflare DNS records with Tailscale IP: $TAILSCALE_IP"
    echo "‚ÑπÔ∏è This will allow access to services via Tailscale VPN network"
    
    # Use variables already defined at the top of the script
    FULL_DOMAIN_NAME="$DOMAIN_NAME"
    
    # Validate that placeholders were replaced (allow empty for optional Cloudflare config)
    CLOUDFLARE_CONFIGURED="false"
    if [[ "$CLOUDFLARE_EMAIL" != "CLOUDFLARE_EMAIL_PLACEHOLDER" && "$CLOUDFLARE_API_TOKEN" != "CLOUDFLARE_API_TOKEN_PLACEHOLDER" && "$FULL_DOMAIN_NAME" != "DOMAIN_NAME_PLACEHOLDER" ]]; then
      if [[ -n "$CLOUDFLARE_EMAIL" && -n "$CLOUDFLARE_API_TOKEN" && -n "$FULL_DOMAIN_NAME" ]]; then
        CLOUDFLARE_CONFIGURED="true"
        echo "‚úÖ Cloudflare DNS configuration detected"
      else
        echo "‚ö†Ô∏è Cloudflare secrets present but some are empty"
      fi
    else
      echo "‚ÑπÔ∏è Cloudflare DNS not configured - skipping DNS updates"
    fi
    
    if [[ "$CLOUDFLARE_CONFIGURED" == "true" ]]; then
      # Extract base domain (e.g., from "nginx.example.com" get "example.com")
      DOMAIN_NAME=$(echo "$FULL_DOMAIN_NAME" | awk -F. '{if(NF>=2) print $(NF-1)"."$NF; else print $0}')
      
      echo "üîç Using domain: $DOMAIN_NAME for zone lookup"
      echo "üîç Full domain to update: $FULL_DOMAIN_NAME"
      
      # Get the zone ID for the domain
      ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$DOMAIN_NAME" \
        -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
        -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
        -H "Content-Type: application/json")
      
      ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id // empty' 2>/dev/null || echo "")
      
      if [[ -n "$ZONE_ID" && "$ZONE_ID" != "null" && "$ZONE_ID" != "empty" ]]; then
        echo "‚úÖ Found Cloudflare zone ID: $ZONE_ID"
        
        # Function to update a single DNS record
        update_dns_record() {
          local record_name="$1"
          local ip_address="$2"
          
          echo "üîÑ Updating DNS record for $record_name..."
          
          # Check if record exists
          local record_response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$record_name&type=A" \
            -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          
          local record_id=$(echo "$record_response" | jq -r '.result[0].id // empty' 2>/dev/null || echo "")
          
          if [[ -n "$record_id" && "$record_id" != "null" && "$record_id" != "empty" ]]; then
            # Update existing record
            local update_response=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$record_id" \
              -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$record_name\",\"content\":\"$ip_address\",\"ttl\":120}")
            
            if echo "$update_response" | jq -e '.success' >/dev/null 2>&1; then
              echo "‚úÖ Updated DNS record $record_name -> $ip_address"
              return 0
            else
              echo "‚ö†Ô∏è Failed to update DNS record for $record_name"
              echo "Response: $(echo "$update_response" | jq '.errors // empty' 2>/dev/null || echo "$update_response")"
              return 1
            fi
          else
            # Create new record
            local create_response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$record_name\",\"content\":\"$ip_address\",\"ttl\":120}")
            
            if echo "$create_response" | jq -e '.success' >/dev/null 2>&1; then
              echo "‚úÖ Created DNS record $record_name -> $ip_address"
              return 0
            else
              echo "‚ö†Ô∏è Failed to create DNS record for $record_name"
              echo "Response: $(echo "$create_response" | jq '.errors // empty' 2>/dev/null || echo "$create_response")"
              return 1
            fi
          fi
        }
        
        # Define DNS records to update based on service
        declare -a dns_records
        
        if [[ "$SERVICE_NAME" == "nginx" ]]; then
          # Nginx service - update ALL proxy-related records (excluding ATS and server-specific records)
          # This list matches your complete DNS zone file to ensure full management
          dns_records=(
            # Core nginx service
            "$FULL_DOMAIN_NAME"           # nginx.7gram.xyz
            
            # Root domain and www
            "$DOMAIN_NAME"                # 7gram.xyz (root domain) 
            "www.$DOMAIN_NAME"            # www.7gram.xyz
            
            # Wildcard and admin
            "*.$DOMAIN_NAME"              # *.7gram.xyz (wildcard)
            "admin.$DOMAIN_NAME"          # admin.7gram.xyz
            
            # Authentication & API
            "auth.$DOMAIN_NAME"           # auth.7gram.xyz
            "api.$DOMAIN_NAME"            # api.7gram.xyz
            
            # Media streaming services
            "emby.$DOMAIN_NAME"           # emby.7gram.xyz
            "jellyfin.$DOMAIN_NAME"       # jellyfin.7gram.xyz
            "plex.$DOMAIN_NAME"           # plex.7gram.xyz
            "music.$DOMAIN_NAME"          # music.7gram.xyz
            "youtube.$DOMAIN_NAME"        # youtube.7gram.xyz
            
            # File management & productivity
            "nc.$DOMAIN_NAME"             # nc.7gram.xyz (nextcloud)
            "calibre.$DOMAIN_NAME"        # calibre.7gram.xyz
            "calibreweb.$DOMAIN_NAME"     # calibreweb.7gram.xyz
            "abs.$DOMAIN_NAME"            # abs.7gram.xyz (audiobookshelf)
            "audiobooks.$DOMAIN_NAME"     # audiobooks.7gram.xyz
            "ebooks.$DOMAIN_NAME"         # ebooks.7gram.xyz
            "duplicati.$DOMAIN_NAME"      # duplicati.7gram.xyz
            "filebot.$DOMAIN_NAME"        # filebot.7gram.xyz
            
            # Home management
            "mealie.$DOMAIN_NAME"         # mealie.7gram.xyz
            "grocy.$DOMAIN_NAME"          # grocy.7gram.xyz
            "wiki.$DOMAIN_NAME"           # wiki.7gram.xyz
            "home.$DOMAIN_NAME"           # home.7gram.xyz
            
            # AI & development
            "ai.$DOMAIN_NAME"             # ai.7gram.xyz
            "chat.$DOMAIN_NAME"           # chat.7gram.xyz
            "ollama.$DOMAIN_NAME"         # ollama.7gram.xyz
            "sd.$DOMAIN_NAME"             # sd.7gram.xyz (stable diffusion)
            "comfy.$DOMAIN_NAME"          # comfy.7gram.xyz
            "whisper.$DOMAIN_NAME"        # whisper.7gram.xyz
            "code.$DOMAIN_NAME"           # code.7gram.xyz
            
            # Media management (*arr stack)
            "sonarr.$DOMAIN_NAME"         # sonarr.7gram.xyz
            "radarr.$DOMAIN_NAME"         # radarr.7gram.xyz
            "lidarr.$DOMAIN_NAME"         # lidarr.7gram.xyz
            "jackett.$DOMAIN_NAME"        # jackett.7gram.xyz
            "qbt.$DOMAIN_NAME"            # qbt.7gram.xyz (qbittorrent)
            
            # Infrastructure & monitoring
            "pihole.$DOMAIN_NAME"         # pihole.7gram.xyz
            "dns.$DOMAIN_NAME"            # dns.7gram.xyz
            "grafana.$DOMAIN_NAME"        # grafana.7gram.xyz
            "prometheus.$DOMAIN_NAME"     # prometheus.7gram.xyz
            "uptime.$DOMAIN_NAME"         # uptime.7gram.xyz
            "watchtower.$DOMAIN_NAME"     # watchtower.7gram.xyz
            "monitor.$DOMAIN_NAME"        # monitor.7gram.xyz
            "nodes.$DOMAIN_NAME"          # nodes.7gram.xyz
            
            # Container management
            "portainer.$DOMAIN_NAME"      # portainer.7gram.xyz
            "portainer-freddy.$DOMAIN_NAME"   # portainer-freddy.7gram.xyz
            "portainer-sullivan.$DOMAIN_NAME" # portainer-sullivan.7gram.xyz
            
            # Mail services
            "mail.$DOMAIN_NAME"           # mail.7gram.xyz
            "smtp.$DOMAIN_NAME"           # smtp.7gram.xyz
            "imap.$DOMAIN_NAME"           # imap.7gram.xyz
            
            # Sync services
            "sync-desktop.$DOMAIN_NAME"   # sync-desktop.7gram.xyz
            "sync-freddy.$DOMAIN_NAME"    # sync-freddy.7gram.xyz
            "sync-oryx.$DOMAIN_NAME"      # sync-oryx.7gram.xyz
            "sync-sullivan.$DOMAIN_NAME"  # sync-sullivan.7gram.xyz
            
            # Utility & status
            "status.$DOMAIN_NAME"         # status.7gram.xyz
            "vpn.$DOMAIN_NAME"            # vpn.7gram.xyz
            "remote.$DOMAIN_NAME"         # remote.7gram.xyz
            
            # Tailscale/VPN internal access records
            "ts-$SERVICE_NAME.$DOMAIN_NAME"     # ts-nginx.7gram.xyz (Tailscale-specific)
            "vpn-$SERVICE_NAME.$DOMAIN_NAME"    # vpn-nginx.7gram.xyz (VPN access)
            "internal-$SERVICE_NAME.$DOMAIN_NAME" # internal-nginx.7gram.xyz (Internal access)
            "tailnet.$DOMAIN_NAME"        # tailnet.7gram.xyz (Tailscale network entry)
            "ts.$DOMAIN_NAME"             # ts.7gram.xyz (Short Tailscale access)
            
            # FKS Trading (legacy support)
            "fkstrading.xyz.$DOMAIN_NAME" # fkstrading.xyz.7gram.xyz
          )
          echo "üåê Updating ${#dns_records[@]} DNS records for nginx service..."
          echo "‚ÑπÔ∏è Excluded from updates (managed by other repositories):"
          echo "   - ats.7gram.xyz (ATS Game Server)"
          echo "   - api.ats.7gram.xyz (ATS API)"
          echo "   - www.ats.7gram.xyz (ATS Web)"
          echo "‚ÑπÔ∏è Excluded from updates (server-specific Tailscale IPs):"
          echo "   - freddy.7gram.xyz (Home automation server)"
          echo "   - sullivan.7gram.xyz (Main media server)"
        elif [[ "$SERVICE_NAME" == "fks" ]]; then
          # FKS service - update FKS-related records
          dns_records=(
            "$FULL_DOMAIN_NAME"           # fks.7gram.xyz
            "api.$DOMAIN_NAME"            # api.7gram.xyz
            "auth.$DOMAIN_NAME"           # auth.7gram.xyz
            "trading.$DOMAIN_NAME"        # trading.7gram.xyz
            "data.$DOMAIN_NAME"           # data.7gram.xyz
          )
          echo "üåê Updating ${#dns_records[@]} DNS records for FKS service..."
        else
          # Other services - just update the main record
          dns_records=("$FULL_DOMAIN_NAME")
          echo "üåê Updating main DNS record for $SERVICE_NAME service..."
        fi
        
        # Update all defined DNS records
        local success_count=0
        local total_count=${#dns_records[@]}
        
        for record in "${dns_records[@]}"; do
          if update_dns_record "$record" "$TAILSCALE_IP"; then
            success_count=$((success_count + 1))
          fi
          sleep 1  # Rate limiting for Cloudflare API
        done
        
        echo "üìä DNS update summary: $success_count/$total_count records updated successfully"
        
        # Verify and update server-specific records if needed
        echo "üîç Verifying server-specific DNS records..."
        
        # Verify and update server-specific records if needed
        echo "üîç Verifying server-specific DNS records..."
        
        # Function to get Tailscale IP for a hostname
        get_tailscale_peer_ip() {
          local hostname="$1"
          # Try to get the IP from tailscale status
          local peer_ip=$(tailscale status --json 2>/dev/null | jq -r --arg hostname "$hostname" '.Peer[] | select(.HostName == $hostname) | .TailscaleIPs[0] // empty' 2>/dev/null || echo "")
          
          if [[ -n "$peer_ip" && "$peer_ip" != "empty" && "$peer_ip" != "null" ]]; then
            echo "$peer_ip"
          else
            # Fallback to known static IPs if peer is not currently online
            case "$hostname" in
              "freddy")
                echo "100.121.199.80"
                ;;
              "sullivan")
                echo "100.86.22.59"
                ;;
              *)
                echo ""
                ;;
            esac
          fi
        }
        
        # Function to check and update server DNS if needed
        check_server_dns() {
          local server_name="$1"
          local record_name="${server_name}.$DOMAIN_NAME"
          
          echo "üîç Checking $record_name..."
          
          # Get expected IP (from Tailscale network or fallback)
          local expected_ip=$(get_tailscale_peer_ip "$server_name")
          
          if [[ -z "$expected_ip" ]]; then
            echo "‚ö†Ô∏è Could not determine expected IP for $server_name"
            return
          fi
          
          # Get current DNS record
          local current_record=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$record_name&type=A" \
            -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          
          local current_ip=$(echo "$current_record" | jq -r '.result[0].content // empty' 2>/dev/null || echo "")
          
          if [[ -n "$current_ip" && "$current_ip" != "empty" ]]; then
            if [[ "$current_ip" == "$expected_ip" ]]; then
              echo "‚úÖ $record_name correctly points to $current_ip"
            else
              echo "‚ö†Ô∏è $record_name points to $current_ip but should point to $expected_ip"
              echo "üîÑ Updating $record_name to correct Tailscale IP..."
              if update_dns_record "$record_name" "$expected_ip"; then
                echo "‚úÖ Updated $record_name to correct IP: $expected_ip"
              else
                echo "‚ùå Failed to update $record_name"
              fi
            fi
          else
            echo "‚ö†Ô∏è $record_name not found in DNS"
            echo "üîÑ Creating $record_name with Tailscale IP..."
            if update_dns_record "$record_name" "$expected_ip"; then
              echo "‚úÖ Created $record_name with IP: $expected_ip"
            else
              echo "‚ùå Failed to create $record_name"
            fi
          fi
        }
        
        # Check freddy server (Home automation server)
        check_server_dns "freddy"
        
        # Check sullivan server (Main media server)  
        check_server_dns "sullivan"
        
        echo "‚úÖ Server DNS verification completed"
        
        # Final DNS verification summary
        echo "üìã DNS Status Summary:"
        echo "======================"
        
        # Check key records for a final summary
        key_records=("$FULL_DOMAIN_NAME" "www.$DOMAIN_NAME" "$DOMAIN_NAME" "freddy.$DOMAIN_NAME" "sullivan.$DOMAIN_NAME")
        
        for record in "${key_records[@]}"; do
          local record_info=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$record&type=A" \
            -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          
          local record_ip=$(echo "$record_info" | jq -r '.result[0].content // "NOT_FOUND"' 2>/dev/null || echo "ERROR")
          printf "%-25s -> %s\n" "$record" "$record_ip"
        done
        
        echo "======================"
        echo "‚úÖ Cloudflare DNS update completed"
      else
        echo "‚ö†Ô∏è Could not find Cloudflare zone for domain: $DOMAIN_NAME"
        echo "Zone response: $ZONE_RESPONSE"
      fi
    else
      echo "‚ÑπÔ∏è Cloudflare DNS updates skipped - not configured or missing credentials"
    fi
  else
    echo "‚ö†Ô∏è Tailscale IP not available - skipping DNS update"
  fi
else
  echo "pending" > /tmp/tailscale_ip
fi

echo "üî• Completing firewall configuration..."
ufw allow in on tailscale0
ufw --force enable

echo "üîê Configuring SSH for service access..."
sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
systemctl restart sshd

echo "üîç Verifying service user configuration..."
id "${SERVICE_NAME}_user" || echo "‚ö†Ô∏è Service user ${SERVICE_NAME}_user not found"

echo "üìä Tailscale status summary..."
if [[ "$TAILSCALE_CONNECTED" == "true" ]]; then
  echo "üîó Tailscale Status:"
  tailscale status --self || echo "‚ö†Ô∏è Could not get tailscale status"
  echo ""
  echo "üåê Advertised Routes:"
  tailscale status --peers=false --self | grep -E "(advertised|routes)" || echo "‚ö†Ô∏è No route information available"
fi

echo "‚úÖ Stage 2 complete - server ready for service deployment"
